{"version":3,"sources":["../node_modules/which-country/lib/base-tree.js","../node_modules/react-geolocated/dist-modules/index.js","../node_modules/react-geolocated/dist-modules/components/geolocated.js","../node_modules/which-country/index.js","../node_modules/which-country/lib/which-country.js","../node_modules/point-in-polygon/index.js","../node_modules/which-country/lib/tree.js","../node_modules/which-country/lib/prebuilt-tree.js","../node_modules/rbush/rbush.js","../node_modules/which-country/lib/new-tree.js"],"names":["rbush","__webpack_require__","module","exports","obj","_geolocated","_geolocated2","__esModule","default","geolocated","geoPropTypes","Object","defineProperty","value","undefined","_extends","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","_createClass","defineProperties","props","descriptor","enumerable","configurable","writable","Constructor","protoProps","staticProps","_react","_react2","_interopRequireDefault","_propTypes2","_ref","_ref$positionOptions","positionOptions","enableHighAccuracy","maximumAge","timeout","Infinity","_ref$isOptimisticGeol","isOptimisticGeolocationEnabled","_ref$userDecisionTime","userDecisionTimeout","_ref$suppressLocation","suppressLocationOnMount","_ref$watchPosition","watchPosition","_ref$geolocationProvi","geolocationProvider","navigator","geolocation","WrappedComponent","result","_Component","Geolocated","instance","TypeError","_classCallCheck","this","_this","self","ReferenceError","_possibleConstructorReturn","__proto__","getPrototypeOf","state","coords","isGeolocationAvailable","Boolean","isGeolocationEnabled","positionError","isCurrentlyMounted","onPositionError","bind","onPositionSuccess","cancelUserDecisionTimeout","getLocation","subClass","superClass","create","constructor","setPrototypeOf","_inherits","Component","userDecisionTimeoutId","clearTimeout","setState","onError","position","onSuccess","_this2","getCurrentPosition","Error","funcPosition","setTimeout","watchId","clearWatch","createElement","displayName","name","getDisplayName","propTypes","func","shape","latitude","number","longitude","altitude","accuracy","altitudeAccuracy","heading","speed","bool","code","oneOf","message","string","pip","tree","contains","polygon","point","r","coordinates","polygons","search","concat","country","vs","x","y","inside","j","xi","yi","xj","yj","e","data","createBaseTree","fromJSON","__WEBPACK_AMD_DEFINE_RESULT__","maxEntries","format","_maxEntries","Math","max","_minEntries","ceil","_initFormat","clear","calcBBox","node","toBBox","bbox","distBBox","children","k","p","child","empty","extend","leaf","a","b","min","compareNodeMinX","compareNodeMinY","bboxArea","bboxMargin","intersectionArea","minX","minY","maxX","maxY","intersects","multiSelect","arr","left","right","n","compare","mid","stack","pop","select","push","z","s","sd","t","log","exp","sqrt","floor","swap","tmp","all","_all","len","childBBox","nodesToSearch","collides","load","insert","_build","slice","height","_splitRoot","tmpNode","_insert","item","remove","parent","index","goingUp","path","indexes","indexOf","splice","_condense","compareMinX","compareMinY","toJSON","apply","items","N","M","pow","right2","right3","N2","N1","_chooseSubtree","level","targetNode","area","enlargement","minArea","minEnlargement","isNode","insertPath","_split","_adjustParentBBoxes","m","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","bbox1","bbox2","overlap","minOverlap","_allDistMargin","sort","leftBBox","rightBBox","margin","siblings","compareArr","Function","join","features","forEach","feature","geometry","type","c","minLng","maxLng","minLat","maxLat","createPolygon","id"],"mappings":"8EAAA,IAAAA,EAAYC,EAAQ,KAMpBC,EAAAC,QAJA,WACA,OAAAH,EAAA,gFCDA,IAIAI,EAJAC,EAAkBJ,EAAQ,KAE1BK,GAEAF,EAFAC,IAGAD,EAAAG,WAAAH,EAAA,CACAI,QAAAJ,GAIAF,EAAAC,QAAA,CACAM,WAAAH,EAAAE,QACAE,aAAAL,EAAAK,gDCZAC,OAAAC,eAAAT,EAAA,cACAU,OAAA,IAEAV,EAAAO,kBAAAI,EAEA,IAAAC,EAAAJ,OAAAK,QAAA,SAAAC,GACA,QAAAC,EAAA,EAAiBA,EAAAC,UAAAC,OAAsBF,IAAA,CACvC,IAAAG,EAAAF,UAAAD,GAEA,QAAAI,KAAAD,EACAV,OAAAY,UAAAC,eAAAC,KAAAJ,EAAAC,KACAL,EAAAK,GAAAD,EAAAC,IAKA,OAAAL,GAGAS,EAAA,WACA,SAAAC,EAAAV,EAAAW,GACA,QAAAV,EAAA,EAAmBA,EAAAU,EAAAR,OAAkBF,IAAA,CACrC,IAAAW,EAAAD,EAAAV,GACAW,EAAAC,WAAAD,EAAAC,aAAA,EACAD,EAAAE,cAAA,EACA,UAAAF,MAAAG,UAAA,GACArB,OAAAC,eAAAK,EAAAY,EAAAP,IAAAO,IAIA,gBAAAI,EAAAC,EAAAC,GAGA,OAFAD,GAAAP,EAAAM,EAAAV,UAAAW,GACAC,GAAAR,EAAAM,EAAAE,GACAF,GAdA,GAkBAG,EAAanC,EAAQ,GAErBoC,EAAAC,EAAAF,GAIAG,EAAAD,EAFiBrC,EAAQ,IAIzB,SAAAqC,EAAAlC,GACA,OAAAA,KAAAG,WAAAH,EAAA,CACAI,QAAAJ,GAoLAD,EAAAK,QA9IA,WACA,IAAAgC,EAAArB,UAAAC,OAAA,QAAAN,IAAAK,UAAA,GAAAA,UAAA,MACAsB,EAAAD,EAAAE,gBACAA,OAAA5B,IAAA2B,EAAA,CACAE,oBAAA,EACAC,WAAA,EACAC,QAAAC,KACGL,EACHM,EAAAP,EAAAQ,+BACAA,OAAAlC,IAAAiC,KACAE,EAAAT,EAAAU,oBACAA,OAAApC,IAAAmC,EAAA,KAAAA,EACAE,EAAAX,EAAAY,wBACAA,OAAAtC,IAAAqC,KACAE,EAAAb,EAAAc,cACAA,OAAAxC,IAAAuC,KACAE,EAAAf,EAAAgB,oBACAA,OAAA1C,IAAAyC,EAAA,qBAAAE,qBAAAC,YAAAH,EAEA,gBAAAI,GACA,IAAAC,EAAA,SAAAC,GAGA,SAAAC,EAAAlC,IAzDA,SAAAmC,EAAA9B,GACA,KAAA8B,aAAA9B,GACA,UAAA+B,UAAA,qCAwDAC,CAAAC,KAAAJ,GAEA,IAAAK,EAtDA,SAAAC,EAAA3C,GACA,IAAA2C,EACA,UAAAC,eAAA,6DAGA,OAAA5C,GAAA,kBAAAA,GAAA,oBAAAA,EAAA2C,EAAA3C,EAiDA6C,CAAAJ,MAAAJ,EAAAS,WAAA5D,OAAA6D,eAAAV,IAAArC,KAAAyC,KAAAtC,IAaA,OAXAuC,EAAAM,MAAA,CACAC,OAAA,KACAC,uBAAAC,QAAApB,GACAqB,qBAAA7B,EACA8B,cAAA,MAEAX,EAAAY,oBAAA,EACAZ,EAAAa,gBAAAb,EAAAa,gBAAAC,KAAAd,GACAA,EAAAe,kBAAAf,EAAAe,kBAAAD,KAAAd,GACAA,EAAAgB,0BAAAhB,EAAAgB,0BAAAF,KAAAd,GACAA,EAAAiB,YAAAjB,EAAAiB,YAAAH,KAAAd,GACAA,EA2FA,OAtJA,SAAAkB,EAAAC,GACA,uBAAAA,GAAA,OAAAA,EACA,UAAAtB,UAAA,kEAAAsB,GAGAD,EAAA9D,UAAAZ,OAAA4E,OAAAD,KAAA/D,UAAA,CACAiE,YAAA,CACA3E,MAAAwE,EACAvD,YAAA,EACAE,UAAA,EACAD,cAAA,KAGAuD,IAAA3E,OAAA8E,eAAA9E,OAAA8E,eAAAJ,EAAAC,GAAAD,EAAAd,UAAAe,GA4BAI,CAAA5B,EA8GK1B,EAAAuD,WAzFLjE,EAAAoC,EAAA,EACAxC,IAAA,4BACAT,MAAA,WACAqD,KAAA0B,uBACAC,aAAA3B,KAAA0B,yBAGO,CACPtE,IAAA,kBACAT,MAAA,SAAAiE,GACAZ,KAAAiB,4BAEAjB,KAAAa,oBACAb,KAAA4B,SAAA,CACApB,OAAA,KACAC,uBAAAT,KAAAO,MAAAE,uBACAE,sBAAA,EACAC,kBAIAZ,KAAAtC,MAAAmE,SACA7B,KAAAtC,MAAAmE,QAAAjB,KAGO,CACPxD,IAAA,oBACAT,MAAA,SAAAmF,GACA9B,KAAAiB,4BAEAjB,KAAAa,oBACAb,KAAA4B,SAAA,CACApB,OAAAsB,EAAAtB,OACAC,uBAAAT,KAAAO,MAAAE,uBACAE,sBAAA,EACAC,cAAA,OAIAZ,KAAAtC,MAAAqE,WACA/B,KAAAtC,MAAAqE,UAAAD,KAGO,CACP1E,IAAA,cACAT,MAAA,WACA,IAAAqF,EAAAhC,KAEA,IAAAV,MAAA2C,qBAAA3C,EAAAF,cACA,UAAA8C,MAAA,gDAGA,IAAAC,GAAA/C,EAAAE,EAAAF,cAAAE,EAAA2C,oBAAAlB,KAAAzB,GAEAN,IACAgB,KAAA0B,sBAAAU,WAAA,WACAJ,EAAAlB,mBACa9B,IAGbgB,KAAAqC,QAAAF,EAAAnC,KAAAgB,kBAAAhB,KAAAc,gBAAAtC,KAEO,CACPpB,IAAA,oBACAT,MAAA,WACAqD,KAAAa,oBAAA,EAEA3B,GACAc,KAAAkB,gBAGO,CACP9D,IAAA,uBACAT,MAAA,WACAqD,KAAAa,oBAAA,EACAb,KAAAiB,4BAEA7B,GACAE,EAAAgD,WAAAtC,KAAAqC,WAGO,CACPjF,IAAA,SACAT,MAAA,WACA,OAAAwB,EAAA7B,QAAAiG,cAAA9C,EAAA5C,EAAA,GAA4EmD,KAAAO,MAAAP,KAAAtC,YAI5EkC,EA9GA,GAsHA,OALAF,EAAA8C,YAzIA,SAAA/C,GACA,qBAAAA,EAAA+C,aAAA/C,EAAAgD,MAAA,iBAwIAC,CAAAjD,GACAC,EAAAiD,UAAA,CACAd,QAAAxD,EAAA/B,QAAAsG,KACAb,UAAA1D,EAAA/B,QAAAsG,MAEAlD,IAKAzD,EAAAO,aAAA,CACAgE,OAAAnC,EAAA/B,QAAAuG,MAAA,CACAC,SAAAzE,EAAA/B,QAAAyG,OACAC,UAAA3E,EAAA/B,QAAAyG,OACAE,SAAA5E,EAAA/B,QAAAyG,OACAG,SAAA7E,EAAA/B,QAAAyG,OACAI,iBAAA9E,EAAA/B,QAAAyG,OACAK,QAAA/E,EAAA/B,QAAAyG,OACAM,MAAAhF,EAAA/B,QAAAyG,SAEAtC,uBAAApC,EAAA/B,QAAAgH,KACA3C,qBAAAtC,EAAA/B,QAAAgH,KACA1C,cAAAvC,EAAA/B,QAAAuG,MAAA,CACAU,KAAAlF,EAAA/B,QAAAkH,MAAA,SACAC,QAAApF,EAAA/B,QAAAoH,SAEAtE,cAAAf,EAAA/B,QAAAgH,2BCtPAtH,EAAAC,QAAiBF,EAAQ,0BCAzB,IAAA4H,EAAU5H,EAAQ,KAElB6H,EAAW7H,EAAQ,IAARA,GAEX,SAAA8H,EAAAC,EAAAC,GAIA,IAHA,IAAAC,EAAAL,EAAAI,EAAAD,EAAAG,YAAA,IACAjH,EAAA,EAEAgH,GAAAhH,EAAA8G,EAAAG,YAAA/G,QACA8G,GAAAL,EAAAI,EAAAD,EAAAG,YAAAjH,MAGA,OAAAgH,EAeAhI,EAAAC,QAVA,SAAA8H,GAGA,IAFA,IAAAG,EAAAN,EAAAO,OAAAJ,EAAAK,OAAAL,IAEA/G,EAAA,EAAiBA,EAAAkH,EAAAhH,OAAqBF,IACtC,GAAA6G,EAAAK,EAAAlH,GAAA+G,GAAA,OAAAG,EAAAlH,GAAAqH,QAGA,gCCxBArI,EAAAC,QAAA,SAAA8H,EAAAO,GAOA,IAJA,IAAAC,EAAAR,EAAA,GACAS,EAAAT,EAAA,GACAU,GAAA,EAEAzH,EAAA,EAAA0H,EAAAJ,EAAApH,OAAA,EAAoCF,EAAAsH,EAAApH,OAAewH,EAAA1H,IAAA,CACnD,IAAA2H,EAAAL,EAAAtH,GAAA,GACA4H,EAAAN,EAAAtH,GAAA,GACA6H,EAAAP,EAAAI,GAAA,GACAI,EAAAR,EAAAI,GAAA,GACAE,EAAAJ,GAAAM,EAAAN,GAAAD,GAAAM,EAAAF,IAAAH,EAAAI,IAAAE,EAAAF,GAAAD,IACAF,MAGA,OAAAA,wBChBA,IACAzI,EAAAC,QAAmBF,EAAQ,KAC1B,MAAAgJ,GACD/I,EAAAC,QAAmBF,EAAQ,2BCH3B,IAAAiJ,EAAWjJ,EAAQ,KAEnBkJ,EAAqBlJ,EAAQ,KAM7BC,EAAAC,QAJA,WACA,OAAAgJ,IAAAC,SAAAF,mtyQCLA,IAAAG,GAKA,WACA,aAEA,SAAArJ,EAAAsJ,EAAAC,GACA,KAAArF,gBAAAlE,GAAA,WAAAA,EAAAsJ,EAAAC,GAEArF,KAAAsF,YAAAC,KAAAC,IAAA,EAAAJ,GAAA,GACApF,KAAAyF,YAAAF,KAAAC,IAAA,EAAAD,KAAAG,KAAA,GAAA1F,KAAAsF,cAEAD,GACArF,KAAA2F,YAAAN,GAGArF,KAAA4F,QA2ZA,SAAAC,EAAAC,EAAAC,GACAD,EAAAE,KAAAC,EAAAH,EAAA,EAAAA,EAAAI,SAAAhJ,OAAA6I,GAIA,SAAAE,EAAAH,EAAAK,EAAAC,EAAAL,GAGA,IAFA,IAEAM,EAFAL,EAAAM,IAEAtJ,EAAAmJ,EAA0BnJ,EAAAoJ,EAAOpJ,IACjCqJ,EAAAP,EAAAI,SAAAlJ,GACAuJ,EAAAP,EAAAF,EAAAU,KAAAT,EAAAM,KAAAL,MAGA,OAAAA,EAGA,SAAAM,IACA,OAAA1H,mBAGA,SAAA2H,EAAAE,EAAAC,GAKA,OAJAD,EAAA,GAAAlB,KAAAoB,IAAAF,EAAA,GAAAC,EAAA,IACAD,EAAA,GAAAlB,KAAAoB,IAAAF,EAAA,GAAAC,EAAA,IACAD,EAAA,GAAAlB,KAAAC,IAAAiB,EAAA,GAAAC,EAAA,IACAD,EAAA,GAAAlB,KAAAC,IAAAiB,EAAA,GAAAC,EAAA,IACAD,EAGA,SAAAG,EAAAH,EAAAC,GACA,OAAAD,EAAAT,KAAA,GAAAU,EAAAV,KAAA,GAGA,SAAAa,EAAAJ,EAAAC,GACA,OAAAD,EAAAT,KAAA,GAAAU,EAAAV,KAAA,GAGA,SAAAc,EAAAL,GACA,OAAAA,EAAA,GAAAA,EAAA,KAAAA,EAAA,GAAAA,EAAA,IAGA,SAAAM,EAAAN,GACA,OAAAA,EAAA,GAAAA,EAAA,IAAAA,EAAA,GAAAA,EAAA,IAOA,SAAAO,EAAAP,EAAAC,GACA,IAAAO,EAAA1B,KAAAC,IAAAiB,EAAA,GAAAC,EAAA,IACAQ,EAAA3B,KAAAC,IAAAiB,EAAA,GAAAC,EAAA,IACAS,EAAA5B,KAAAoB,IAAAF,EAAA,GAAAC,EAAA,IACAU,EAAA7B,KAAAoB,IAAAF,EAAA,GAAAC,EAAA,IACA,OAAAnB,KAAAC,IAAA,EAAA2B,EAAAF,GAAA1B,KAAAC,IAAA,EAAA4B,EAAAF,GAGA,SAAArD,EAAA4C,EAAAC,GACA,OAAAD,EAAA,IAAAC,EAAA,IAAAD,EAAA,IAAAC,EAAA,IAAAA,EAAA,IAAAD,EAAA,IAAAC,EAAA,IAAAD,EAAA,GAGA,SAAAY,EAAAZ,EAAAC,GACA,OAAAA,EAAA,IAAAD,EAAA,IAAAC,EAAA,IAAAD,EAAA,IAAAC,EAAA,IAAAD,EAAA,IAAAC,EAAA,IAAAD,EAAA,GAKA,SAAAa,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAIA,IAHA,IACAC,EADAC,EAAA,CAAAL,EAAAC,GAGAI,EAAA3K,SACAuK,EAAAI,EAAAC,QACAN,EAAAK,EAAAC,QACAJ,IAEAK,EAAAR,EAAAC,EAAAC,EADAG,EAAAJ,EAAAjC,KAAAG,MAAA+B,EAAAD,GAAAE,EAAA,GAAAA,EACAC,GACAE,EAAAG,KAAAR,EAAAI,IAAAH,IAMA,SAAAM,EAAAR,EAAAC,EAAAC,EAAAtB,EAAAwB,GAGA,IAFA,IAAAD,EAAA1K,EAAAiL,EAAAC,EAAAC,EAAAC,EAAA1D,EAEA+C,EAAAD,GAAA,CAkBA,IAjBAC,EAAAD,EAAA,MACAE,EAAAD,EAAAD,EAAA,EACAxK,EAAAmJ,EAAAqB,EAAA,EACAS,EAAA1C,KAAA8C,IAAAX,GACAQ,EAAA,GAAA3C,KAAA+C,IAAA,EAAAL,EAAA,GACAE,EAAA,GAAA5C,KAAAgD,KAAAN,EAAAC,GAAAR,EAAAQ,GAAAR,IAAA1K,EAAA0K,EAAA,UAGAK,EAAAR,EAFAhC,KAAAC,IAAAgC,EAAAjC,KAAAiD,MAAArC,EAAAnJ,EAAAkL,EAAAR,EAAAS,IACA5C,KAAAoB,IAAAc,EAAAlC,KAAAiD,MAAArC,GAAAuB,EAAA1K,GAAAkL,EAAAR,EAAAS,IACAhC,EAAAwB,IAGAS,EAAAb,EAAApB,GACAnJ,EAAAwK,EACA9C,EAAA+C,EACAgB,EAAAlB,EAAAC,EAAArB,GACAwB,EAAAJ,EAAAE,GAAAW,GAAA,GAAAK,EAAAlB,EAAAC,EAAAC,GAEAzK,EAAA0H,GAAA,CAKA,IAJA+D,EAAAlB,EAAAvK,EAAA0H,GACA1H,IACA0H,IAEAiD,EAAAJ,EAAAvK,GAAAoL,GAAA,GACApL,IAGA,KAAA2K,EAAAJ,EAAA7C,GAAA0D,GAAA,GACA1D,IAIA,IAAAiD,EAAAJ,EAAAC,GAAAY,GAAAK,EAAAlB,EAAAC,EAAA9C,GAEA+D,EAAAlB,IADA7C,EACA+C,GAEA/C,GAAAyB,IAAAqB,EAAA9C,EAAA,GACAyB,GAAAzB,IAAA+C,EAAA/C,EAAA,IAIA,SAAA+D,EAAAlB,EAAAvK,EAAA0H,GACA,IAAAgE,EAAAnB,EAAAvK,GACAuK,EAAAvK,GAAAuK,EAAA7C,GACA6C,EAAA7C,GAAAgE,EAzhBA5M,EAAAuB,UAAA,CACAsL,IAAA,WACA,OAAA3I,KAAA4I,KAAA5I,KAAAgF,KAAA,KAEAb,OAAA,SAAA6B,GACA,IAAAF,EAAA9F,KAAAgF,KACAtF,EAAA,GACAqG,EAAA/F,KAAA+F,OACA,IAAAsB,EAAArB,EAAAF,EAAAE,MAAA,OAAAtG,EAOA,IANA,IACA1C,EACA6L,EACAxC,EACAyC,EAJAC,EAAA,GAMAjD,GAAA,CACA,IAAA9I,EAAA,EAAA6L,EAAA/C,EAAAI,SAAAhJ,OAA+CF,EAAA6L,EAAS7L,IACxDqJ,EAAAP,EAAAI,SAAAlJ,GAGAqK,EAAArB,EAFA8C,EAAAhD,EAAAU,KAAAT,EAAAM,KAAAL,QAGAF,EAAAU,KAAA9G,EAAAsI,KAAA3B,GAA8CxC,EAAAmC,EAAA8C,GAAA9I,KAAA4I,KAAAvC,EAAA3G,GAA6DqJ,EAAAf,KAAA3B,IAI3GP,EAAAiD,EAAAjB,MAGA,OAAApI,GAEAsJ,SAAA,SAAAhD,GACA,IAAAF,EAAA9F,KAAAgF,KACAe,EAAA/F,KAAA+F,OACA,IAAAsB,EAAArB,EAAAF,EAAAE,MAAA,SAOA,IANA,IACAhJ,EACA6L,EACAxC,EACAyC,EAJAC,EAAA,GAMAjD,GAAA,CACA,IAAA9I,EAAA,EAAA6L,EAAA/C,EAAAI,SAAAhJ,OAA+CF,EAAA6L,EAAS7L,IAIxD,GAHAqJ,EAAAP,EAAAI,SAAAlJ,GAGAqK,EAAArB,EAFA8C,EAAAhD,EAAAU,KAAAT,EAAAM,KAAAL,MAEA,CACA,GAAAF,EAAAU,MAAA3C,EAAAmC,EAAA8C,GAAA,SACAC,EAAAf,KAAA3B,GAIAP,EAAAiD,EAAAjB,MAGA,UAEAmB,KAAA,SAAAjE,GACA,IAAAA,MAAA9H,OAAA,OAAA8C,KAEA,GAAAgF,EAAA9H,OAAA8C,KAAAyF,YAAA,CACA,QAAAzI,EAAA,EAAA6L,EAAA7D,EAAA9H,OAA0CF,EAAA6L,EAAS7L,IACnDgD,KAAAkJ,OAAAlE,EAAAhI,IAGA,OAAAgD,KAIA,IAAA8F,EAAA9F,KAAAmJ,OAAAnE,EAAAoE,QAAA,EAAApE,EAAA9H,OAAA,KAEA,GAAA8C,KAAAgF,KAAAkB,SAAAhJ,OAGO,GAAA8C,KAAAgF,KAAAqE,SAAAvD,EAAAuD,OAEPrJ,KAAAsJ,WAAAtJ,KAAAgF,KAAAc,OACO,CACP,GAAA9F,KAAAgF,KAAAqE,OAAAvD,EAAAuD,OAAA,CAEA,IAAAE,EAAAvJ,KAAAgF,KACAhF,KAAAgF,KAAAc,EACAA,EAAAyD,EAIAvJ,KAAAwJ,QAAA1D,EAAA9F,KAAAgF,KAAAqE,OAAAvD,EAAAuD,OAAA,WAbArJ,KAAAgF,KAAAc,EAgBA,OAAA9F,MAEAkJ,OAAA,SAAAO,GAEA,OADAA,GAAAzJ,KAAAwJ,QAAAC,EAAAzJ,KAAAgF,KAAAqE,OAAA,GACArJ,MAEA4F,MAAA,WAOA,OANA5F,KAAAgF,KAAA,CACAkB,SAAA,GACAmD,OAAA,EACArD,KAAAM,IACAE,MAAA,GAEAxG,MAEA0J,OAAA,SAAAD,GACA,IAAAA,EAAA,OAAAzJ,KAUA,IATA,IAIAhD,EACA2M,EACAC,EACAC,EAPA/D,EAAA9F,KAAAgF,KACAgB,EAAAhG,KAAA+F,OAAA0D,GACAK,EAAA,GACAC,EAAA,GAMAjE,GAAAgE,EAAA5M,QAAA,CASA,GARA4I,IAEAA,EAAAgE,EAAAhC,MACA6B,EAAAG,IAAA5M,OAAA,GACAF,EAAA+M,EAAAjC,MACA+B,GAAA,GAGA/D,EAAAU,OAIA,KAFAoD,EAAA9D,EAAAI,SAAA8D,QAAAP,IASA,OALA3D,EAAAI,SAAA+D,OAAAL,EAAA,GACAE,EAAA9B,KAAAlC,GAEA9F,KAAAkK,UAAAJ,GAEA9J,KAIA6J,GAAA/D,EAAAU,OAAA3C,EAAAiC,EAAAE,QAOS2D,GAET3M,IACA8I,EAAA6D,EAAAzD,SAAAlJ,GACA6M,GAAA,GACS/D,EAAA,MAVTgE,EAAA9B,KAAAlC,GACAiE,EAAA/B,KAAAhL,GACAA,EAAA,EACA2M,EAAA7D,EACAA,IAAAI,SAAA,IAUA,OAAAlG,MAEA+F,OAAA,SAAA0D,GACA,OAAAA,GAEAU,YAAA,SAAA1D,EAAAC,GACA,OAAAD,EAAA,GAAAC,EAAA,IAEA0D,YAAA,SAAA3D,EAAAC,GACA,OAAAD,EAAA,GAAAC,EAAA,IAEA2D,OAAA,WACA,OAAArK,KAAAgF,MAEAE,SAAA,SAAAF,GAEA,OADAhF,KAAAgF,OACAhF,MAEA4I,KAAA,SAAA9C,EAAApG,GAGA,IAFA,IAAAqJ,EAAA,GAEAjD,GACAA,EAAAU,KAAA9G,EAAAsI,KAAAsC,MAAA5K,EAAAoG,EAAAI,UAAgE6C,EAAAf,KAAAsC,MAAAvB,EAAAjD,EAAAI,UAChEJ,EAAAiD,EAAAjB,MAGA,OAAApI,GAEAyJ,OAAA,SAAAoB,EAAA/C,EAAAC,EAAA4B,GACA,IAEAvD,EAFA0E,EAAA/C,EAAAD,EAAA,EACAiD,EAAAzK,KAAAsF,YAGA,GAAAkF,GAAAC,EASA,OADA5E,EANAC,EAAA,CACAI,SAAAqE,EAAAnB,MAAA5B,EAAAC,EAAA,GACA4B,OAAA,EACArD,KAAA,KACAQ,MAAA,GAEAxG,KAAA+F,QACAD,EAGAuD,IAEAA,EAAA9D,KAAAG,KAAAH,KAAA8C,IAAAmC,GAAAjF,KAAA8C,IAAAoC,IAEAA,EAAAlF,KAAAG,KAAA8E,EAAAjF,KAAAmF,IAAAD,EAAApB,EAAA,KAGAvD,EAAA,CACAI,SAAA,GACAmD,SACArD,KAAA,KACAQ,MAAA,GAGA,IAEAxJ,EACA0H,EACAiG,EACAC,EALAC,EAAAtF,KAAAG,KAAA8E,EAAAC,GACAK,EAAAD,EAAAtF,KAAAG,KAAAH,KAAAgD,KAAAkC,IAOA,IAFAnD,EAAAiD,EAAA/C,EAAAC,EAAAqD,EAAA9K,KAAAmK,aAEAnN,EAAAwK,EAAoBxK,GAAAyK,EAAYzK,GAAA8N,EAIhC,IAFAxD,EAAAiD,EAAAvN,EADA2N,EAAApF,KAAAoB,IAAA3J,EAAA8N,EAAA,EAAArD,GACAoD,EAAA7K,KAAAoK,aAEA1F,EAAA1H,EAAmB0H,GAAAiG,EAAajG,GAAAmG,EAChCD,EAAArF,KAAAoB,IAAAjC,EAAAmG,EAAA,EAAAF,GAEA7E,EAAAI,SAAA8B,KAAAhI,KAAAmJ,OAAAoB,EAAA7F,EAAAkG,EAAAvB,EAAA,IAKA,OADAxD,EAAAC,EAAA9F,KAAA+F,QACAD,GAEAiF,eAAA,SAAA/E,EAAAF,EAAAkF,EAAAlB,GAGA,IAFA,IAAA9M,EAAA6L,EAAAxC,EAAA4E,EAAAC,EAAAC,EAAAC,EAAAC,EAwNA5E,EAAAC,EArNAoD,EAAA9B,KAAAlC,IACAA,EAAAU,MAAAsD,EAAA5M,OAAA,IAAA8N,GAFA,CAKA,IAFAI,EAAAC,EAAAzM,IAEA5B,EAAA,EAAA6L,EAAA/C,EAAAI,SAAAhJ,OAA+CF,EAAA6L,EAAS7L,IAExDkO,EAAApE,GADAT,EAAAP,EAAAI,SAAAlJ,IACAgJ,MA+MAS,EA9MAT,EA8MAU,EA9MAL,EAAAL,MAAAmF,GA+MA5F,KAAAC,IAAAkB,EAAA,GAAAD,EAAA,IAAAlB,KAAAoB,IAAAD,EAAA,GAAAD,EAAA,MAAAlB,KAAAC,IAAAkB,EAAA,GAAAD,EAAA,IAAAlB,KAAAoB,IAAAD,EAAA,GAAAD,EAAA,KA/MAyE,GAEAG,GACAA,EAAAF,EACAC,EAAAF,EAAAE,EAAAF,EAAAE,EACAH,EAAA5E,GACW8E,IAAAE,GAEXH,EAAAE,IACAA,EAAAF,EACAD,EAAA5E,GAKAP,EAAAmF,GAAAnF,EAAAI,SAAA,GAGA,OAAAJ,GAEA0D,QAAA,SAAAC,EAAAuB,EAAAM,GACA,IAAAvF,EAAA/F,KAAA+F,OACAC,EAAAsF,EAAA7B,EAAAzD,KAAAD,EAAA0D,GACA8B,EAAA,GAEAzF,EAAA9F,KAAA+K,eAAA/E,EAAAhG,KAAAgF,KAAAgG,EAAAO,GAMA,IAHAzF,EAAAI,SAAA8B,KAAAyB,GACAlD,EAAAT,EAAAE,QAEAgF,GAAA,GACAO,EAAAP,GAAA9E,SAAAhJ,OAAA8C,KAAAsF,aACAtF,KAAAwL,OAAAD,EAAAP,GAEAA,IAKAhL,KAAAyL,oBAAAzF,EAAAuF,EAAAP,IAGAQ,OAAA,SAAAD,EAAAP,GACA,IAAAlF,EAAAyF,EAAAP,GACAP,EAAA3E,EAAAI,SAAAhJ,OACAwO,EAAA1L,KAAAyF,YAEAzF,KAAA2L,iBAAA7F,EAAA4F,EAAAjB,GAEA,IAAAmB,EAAA5L,KAAA6L,kBAAA/F,EAAA4F,EAAAjB,GAEAqB,EAAA,CACA5F,SAAAJ,EAAAI,SAAA+D,OAAA2B,EAAA9F,EAAAI,SAAAhJ,OAAA0O,GACAvC,OAAAvD,EAAAuD,OACArD,KAAA,KACAQ,MAAA,GAEAV,EAAAU,OAAAsF,EAAAtF,MAAA,GACAX,EAAAC,EAAA9F,KAAA+F,QACAF,EAAAiG,EAAA9L,KAAA+F,QACAiF,EAAAO,EAAAP,EAAA,GAAA9E,SAAA8B,KAAA8D,GAA8D9L,KAAAsJ,WAAAxD,EAAAgG,IAE9DxC,WAAA,SAAAxD,EAAAgG,GAEA9L,KAAAgF,KAAA,CACAkB,SAAA,CAAAJ,EAAAgG,GACAzC,OAAAvD,EAAAuD,OAAA,EACArD,KAAA,KACAQ,MAAA,GAEAX,EAAA7F,KAAAgF,KAAAhF,KAAA+F,SAEA8F,kBAAA,SAAA/F,EAAA4F,EAAAjB,GACA,IAAAzN,EAAA+O,EAAAC,EAAAC,EAAAf,EAAAgB,EAAAd,EAAAxB,EAGA,IAFAsC,EAAAd,EAAAxM,IAEA5B,EAAA0O,EAAiB1O,GAAAyN,EAAAiB,EAAY1O,IAG7BiP,EAAAjF,EAFA+E,EAAA9F,EAAAH,EAAA,EAAA9I,EAAAgD,KAAA+F,QACAiG,EAAA/F,EAAAH,EAAA9I,EAAAyN,EAAAzK,KAAA+F,SAEAmF,EAAApE,EAAAiF,GAAAjF,EAAAkF,GAEAC,EAAAC,GACAA,EAAAD,EACArC,EAAA5M,EACAoO,EAAAF,EAAAE,EAAAF,EAAAE,GACSa,IAAAC,GAEThB,EAAAE,IACAA,EAAAF,EACAtB,EAAA5M,GAKA,OAAA4M,GAGA+B,iBAAA,SAAA7F,EAAA4F,EAAAjB,GACA,IAAAN,EAAArE,EAAAU,KAAAxG,KAAAmK,YAAAvD,EACAwD,EAAAtE,EAAAU,KAAAxG,KAAAoK,YAAAvD,EACA7G,KAAAmM,eAAArG,EAAA4F,EAAAjB,EAAAN,GACAnK,KAAAmM,eAAArG,EAAA4F,EAAAjB,EAAAL,IAIAtE,EAAAI,SAAAkG,KAAAjC,IAGAgC,eAAA,SAAArG,EAAA4F,EAAAjB,EAAA9C,GACA7B,EAAAI,SAAAkG,KAAAzE,GACA,IAIA3K,EACAqJ,EALAN,EAAA/F,KAAA+F,OACAsG,EAAApG,EAAAH,EAAA,EAAA4F,EAAA3F,GACAuG,EAAArG,EAAAH,EAAA2E,EAAAiB,EAAAjB,EAAA1E,GACAwG,EAAAxF,EAAAsF,GAAAtF,EAAAuF,GAIA,IAAAtP,EAAA0O,EAAiB1O,EAAAyN,EAAAiB,EAAW1O,IAC5BqJ,EAAAP,EAAAI,SAAAlJ,GACAuJ,EAAA8F,EAAAvG,EAAAU,KAAAT,EAAAM,KAAAL,MACAuG,GAAAxF,EAAAsF,GAGA,IAAArP,EAAAyN,EAAAiB,EAAA,EAAyB1O,GAAA0O,EAAQ1O,IACjCqJ,EAAAP,EAAAI,SAAAlJ,GACAuJ,EAAA+F,EAAAxG,EAAAU,KAAAT,EAAAM,KAAAL,MACAuG,GAAAxF,EAAAuF,GAGA,OAAAC,GAEAd,oBAAA,SAAAzF,EAAA8D,EAAAkB,GAEA,QAAAhO,EAAAgO,EAAyBhO,GAAA,EAAQA,IACjCuJ,EAAAuD,EAAA9M,GAAAgJ,SAGAkE,UAAA,SAAAJ,GAEA,QAAA0C,EAAAxP,EAAA8M,EAAA5M,OAAA,EAA6CF,GAAA,EAAQA,IACrD,IAAA8M,EAAA9M,GAAAkJ,SAAAhJ,OACAF,EAAA,GACAwP,EAAA1C,EAAA9M,EAAA,GAAAkJ,UACA+D,OAAAuC,EAAAxC,QAAAF,EAAA9M,IAAA,GACWgD,KAAA4F,QACFC,EAAAiE,EAAA9M,GAAAgD,KAAA+F,SAGTJ,YAAA,SAAAN,GAKA,IAAAoH,EAAA,wBACAzM,KAAAmK,YAAA,IAAAuC,SAAA,QAAAD,EAAAE,KAAAtH,EAAA,KACArF,KAAAoK,YAAA,IAAAsC,SAAA,QAAAD,EAAAE,KAAAtH,EAAA,KACArF,KAAA+F,OAAA,IAAA2G,SAAA,gBAAArH,EAAAsH,KAAA,oBA2IG/P,KAF+CuI,EAAA,WAClD,OAAArJ,GACGyB,KAAAtB,EAAAF,EAAAE,EAAAD,QAAAC,QAAAkJ,GA/iBH,wBCLA,IAAAH,EAAWjJ,EAAQ,KAEnBkJ,EAAqBlJ,EAAQ,KAkD7BC,EAAAC,QAzBA,WACA,IAAA2H,EAAAqB,IAqBA,OApBAD,EAAA4H,SAAAC,QAAA,SAAAC,GACA,IAAA7I,EAEA,OAAA6I,EAAAC,SAAAC,MACA,cACA/I,EAAA,CAAA6I,EAAAC,SAAA9I,aACA,MAEA,mBACAA,EAAA6I,EAAAC,SAAA9I,YACA,MAEA,QACA,UAAA/B,MAAA,wBAGA+B,EAAA4I,QAAA,SAAAI,GACArJ,EAAAsF,OA1CA,SAAAjF,EAAAI,GAOA,IANA,IAAA7D,EAAAyD,EAAA,GACAiJ,EAAA1M,EAAA,MACA2M,EAAA3M,EAAA,MACA4M,EAAA5M,EAAA,MACA6M,EAAA7M,EAAA,MAEAxD,EAAA,EAAiBA,EAAAwD,EAAAtD,OAAmBF,IAAA,CACpC,IAAA+G,EAAAvD,EAAAxD,GACA+G,EAAA,GAAAmJ,IAAAnJ,EAAA,GAA6CA,EAAA,GAAAoJ,MAAApJ,EAAA,IAC7CA,EAAA,GAAAqJ,IAAArJ,EAAA,GAA6CA,EAAA,GAAAsJ,MAAAtJ,EAAA,IAG7C,OACAM,UACAJ,cACAiJ,SACAE,SACAD,SACAE,UAuBAC,CAAAL,EAAAH,EAAAS,SAGA3J","file":"static/js/48.bc08cad3.chunk.js","sourcesContent":["var rbush = require('rbush');\n\nfunction tree() {\n  return rbush(7, ['.minLng', '.minLat', '.maxLng', '.maxLat']);\n}\n\nmodule.exports = tree;","\"use strict\";\n\nvar _geolocated = require(\"./components/geolocated\");\n\nvar _geolocated2 = _interopRequireDefault(_geolocated);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nmodule.exports = {\n  geolocated: _geolocated2.default,\n  geoPropTypes: _geolocated.geoPropTypes\n};","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.geoPropTypes = undefined;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _react = require(\"react\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require(\"prop-types\");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction getDisplayName(WrappedComponent) {\n  return \"Geolocated(\" + (WrappedComponent.displayName || WrappedComponent.name || \"Component\") + \")\";\n}\n\nvar geolocated = function geolocated() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$positionOptions = _ref.positionOptions,\n      positionOptions = _ref$positionOptions === undefined ? {\n    enableHighAccuracy: true,\n    maximumAge: 0,\n    timeout: Infinity\n  } : _ref$positionOptions,\n      _ref$isOptimisticGeol = _ref.isOptimisticGeolocationEnabled,\n      isOptimisticGeolocationEnabled = _ref$isOptimisticGeol === undefined ? true : _ref$isOptimisticGeol,\n      _ref$userDecisionTime = _ref.userDecisionTimeout,\n      userDecisionTimeout = _ref$userDecisionTime === undefined ? null : _ref$userDecisionTime,\n      _ref$suppressLocation = _ref.suppressLocationOnMount,\n      suppressLocationOnMount = _ref$suppressLocation === undefined ? false : _ref$suppressLocation,\n      _ref$watchPosition = _ref.watchPosition,\n      watchPosition = _ref$watchPosition === undefined ? false : _ref$watchPosition,\n      _ref$geolocationProvi = _ref.geolocationProvider,\n      geolocationProvider = _ref$geolocationProvi === undefined ? typeof navigator !== \"undefined\" && navigator.geolocation : _ref$geolocationProvi;\n\n  return function (WrappedComponent) {\n    var result = function (_Component) {\n      _inherits(Geolocated, _Component);\n\n      function Geolocated(props) {\n        _classCallCheck(this, Geolocated);\n\n        var _this = _possibleConstructorReturn(this, (Geolocated.__proto__ || Object.getPrototypeOf(Geolocated)).call(this, props));\n\n        _this.state = {\n          coords: null,\n          isGeolocationAvailable: Boolean(geolocationProvider),\n          isGeolocationEnabled: isOptimisticGeolocationEnabled,\n          positionError: null\n        };\n        _this.isCurrentlyMounted = false;\n        _this.onPositionError = _this.onPositionError.bind(_this);\n        _this.onPositionSuccess = _this.onPositionSuccess.bind(_this);\n        _this.cancelUserDecisionTimeout = _this.cancelUserDecisionTimeout.bind(_this);\n        _this.getLocation = _this.getLocation.bind(_this);\n        return _this;\n      }\n\n      _createClass(Geolocated, [{\n        key: \"cancelUserDecisionTimeout\",\n        value: function cancelUserDecisionTimeout() {\n          if (this.userDecisionTimeoutId) {\n            clearTimeout(this.userDecisionTimeoutId);\n          }\n        }\n      }, {\n        key: \"onPositionError\",\n        value: function onPositionError(positionError) {\n          this.cancelUserDecisionTimeout();\n\n          if (this.isCurrentlyMounted) {\n            this.setState({\n              coords: null,\n              isGeolocationAvailable: this.state.isGeolocationAvailable,\n              isGeolocationEnabled: false,\n              positionError: positionError\n            });\n          }\n\n          if (this.props.onError) {\n            this.props.onError(positionError);\n          }\n        }\n      }, {\n        key: \"onPositionSuccess\",\n        value: function onPositionSuccess(position) {\n          this.cancelUserDecisionTimeout();\n\n          if (this.isCurrentlyMounted) {\n            this.setState({\n              coords: position.coords,\n              isGeolocationAvailable: this.state.isGeolocationAvailable,\n              isGeolocationEnabled: true,\n              positionError: null\n            });\n          }\n\n          if (this.props.onSuccess) {\n            this.props.onSuccess(position);\n          }\n        }\n      }, {\n        key: \"getLocation\",\n        value: function getLocation() {\n          var _this2 = this;\n\n          if (!geolocationProvider || !geolocationProvider.getCurrentPosition || !geolocationProvider.watchPosition) {\n            throw new Error(\"The provided geolocation provider is invalid\");\n          }\n\n          var funcPosition = (watchPosition ? geolocationProvider.watchPosition : geolocationProvider.getCurrentPosition).bind(geolocationProvider);\n\n          if (userDecisionTimeout) {\n            this.userDecisionTimeoutId = setTimeout(function () {\n              _this2.onPositionError();\n            }, userDecisionTimeout);\n          }\n\n          this.watchId = funcPosition(this.onPositionSuccess, this.onPositionError, positionOptions);\n        }\n      }, {\n        key: \"componentDidMount\",\n        value: function componentDidMount() {\n          this.isCurrentlyMounted = true;\n\n          if (!suppressLocationOnMount) {\n            this.getLocation();\n          }\n        }\n      }, {\n        key: \"componentWillUnmount\",\n        value: function componentWillUnmount() {\n          this.isCurrentlyMounted = false;\n          this.cancelUserDecisionTimeout();\n\n          if (watchPosition) {\n            geolocationProvider.clearWatch(this.watchId);\n          }\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          return _react2.default.createElement(WrappedComponent, _extends({}, this.state, this.props));\n        }\n      }]);\n\n      return Geolocated;\n    }(_react.Component);\n\n    result.displayName = getDisplayName(WrappedComponent);\n    result.propTypes = {\n      onError: _propTypes2.default.func,\n      onSuccess: _propTypes2.default.func\n    };\n    return result;\n  };\n};\n\nexports.default = geolocated;\nvar geoPropTypes = exports.geoPropTypes = {\n  coords: _propTypes2.default.shape({\n    latitude: _propTypes2.default.number,\n    longitude: _propTypes2.default.number,\n    altitude: _propTypes2.default.number,\n    accuracy: _propTypes2.default.number,\n    altitudeAccuracy: _propTypes2.default.number,\n    heading: _propTypes2.default.number,\n    speed: _propTypes2.default.number\n  }),\n  isGeolocationAvailable: _propTypes2.default.bool,\n  isGeolocationEnabled: _propTypes2.default.bool,\n  positionError: _propTypes2.default.shape({\n    code: _propTypes2.default.oneOf([1, 2, 3]),\n    message: _propTypes2.default.string\n  }),\n  watchPosition: _propTypes2.default.bool\n};","module.exports = require('./lib/which-country.js');","var pip = require('point-in-polygon');\n\nvar tree = require('./tree.js')();\n\nfunction contains(polygon, point) {\n  var r = pip(point, polygon.coordinates[0]);\n  var i = 1;\n\n  while (r && i < polygon.coordinates.length) {\n    r = !pip(point, polygon.coordinates[i++]);\n  }\n\n  return r;\n}\n\n;\n\nfunction country(point) {\n  var polygons = tree.search(point.concat(point));\n\n  for (var i = 0; i < polygons.length; i++) {\n    if (contains(polygons[i], point)) return polygons[i].country;\n  }\n\n  return null;\n}\n\nmodule.exports = country;","module.exports = function (point, vs) {\n  // ray-casting algorithm based on\n  // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n  var x = point[0],\n      y = point[1];\n  var inside = false;\n\n  for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {\n    var xi = vs[i][0],\n        yi = vs[i][1];\n    var xj = vs[j][0],\n        yj = vs[j][1];\n    var intersect = yi > y != yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;\n    if (intersect) inside = !inside;\n  }\n\n  return inside;\n};","try {\n  module.exports = require('./prebuilt-tree.js');\n} catch (e) {\n  module.exports = require('./new-tree.js');\n}","var data = require('../data.json');\n\nvar createBaseTree = require('./base-tree.js');\n\nfunction createPrebuiltTree() {\n  return createBaseTree().fromJSON(data);\n}\n\nmodule.exports = createPrebuiltTree;","/*\n (c) 2015, Vladimir Agafonkin\n RBush, a JavaScript library for high-performance 2D spatial indexing of points and rectangles.\n https://github.com/mourner/rbush\n*/\n(function () {\n  'use strict';\n\n  function rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format); // max entries in a node is 9 by default; min node fill is 40% for best performance\n\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n      this._initFormat(format);\n    }\n\n    this.clear();\n  }\n\n  rbush.prototype = {\n    all: function all() {\n      return this._all(this.data, []);\n    },\n    search: function search(bbox) {\n      var node = this.data,\n          result = [],\n          toBBox = this.toBBox;\n      if (!intersects(bbox, node.bbox)) return result;\n      var nodesToSearch = [],\n          i,\n          len,\n          child,\n          childBBox;\n\n      while (node) {\n        for (i = 0, len = node.children.length; i < len; i++) {\n          child = node.children[i];\n          childBBox = node.leaf ? toBBox(child) : child.bbox;\n\n          if (intersects(bbox, childBBox)) {\n            if (node.leaf) result.push(child);else if (contains(bbox, childBBox)) this._all(child, result);else nodesToSearch.push(child);\n          }\n        }\n\n        node = nodesToSearch.pop();\n      }\n\n      return result;\n    },\n    collides: function collides(bbox) {\n      var node = this.data,\n          toBBox = this.toBBox;\n      if (!intersects(bbox, node.bbox)) return false;\n      var nodesToSearch = [],\n          i,\n          len,\n          child,\n          childBBox;\n\n      while (node) {\n        for (i = 0, len = node.children.length; i < len; i++) {\n          child = node.children[i];\n          childBBox = node.leaf ? toBBox(child) : child.bbox;\n\n          if (intersects(bbox, childBBox)) {\n            if (node.leaf || contains(bbox, childBBox)) return true;\n            nodesToSearch.push(child);\n          }\n        }\n\n        node = nodesToSearch.pop();\n      }\n\n      return false;\n    },\n    load: function load(data) {\n      if (!(data && data.length)) return this;\n\n      if (data.length < this._minEntries) {\n        for (var i = 0, len = data.length; i < len; i++) {\n          this.insert(data[i]);\n        }\n\n        return this;\n      } // recursively build the tree with the given data from stratch using OMT algorithm\n\n\n      var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n      if (!this.data.children.length) {\n        // save as is if tree is empty\n        this.data = node;\n      } else if (this.data.height === node.height) {\n        // split root if trees have the same height\n        this._splitRoot(this.data, node);\n      } else {\n        if (this.data.height < node.height) {\n          // swap trees if inserted one is bigger\n          var tmpNode = this.data;\n          this.data = node;\n          node = tmpNode;\n        } // insert the small tree into the large tree at appropriate level\n\n\n        this._insert(node, this.data.height - node.height - 1, true);\n      }\n\n      return this;\n    },\n    insert: function insert(item) {\n      if (item) this._insert(item, this.data.height - 1);\n      return this;\n    },\n    clear: function clear() {\n      this.data = {\n        children: [],\n        height: 1,\n        bbox: empty(),\n        leaf: true\n      };\n      return this;\n    },\n    remove: function remove(item) {\n      if (!item) return this;\n      var node = this.data,\n          bbox = this.toBBox(item),\n          path = [],\n          indexes = [],\n          i,\n          parent,\n          index,\n          goingUp; // depth-first iterative tree traversal\n\n      while (node || path.length) {\n        if (!node) {\n          // go up\n          node = path.pop();\n          parent = path[path.length - 1];\n          i = indexes.pop();\n          goingUp = true;\n        }\n\n        if (node.leaf) {\n          // check current node\n          index = node.children.indexOf(item);\n\n          if (index !== -1) {\n            // item found, remove the item and condense tree upwards\n            node.children.splice(index, 1);\n            path.push(node);\n\n            this._condense(path);\n\n            return this;\n          }\n        }\n\n        if (!goingUp && !node.leaf && contains(node.bbox, bbox)) {\n          // go down\n          path.push(node);\n          indexes.push(i);\n          i = 0;\n          parent = node;\n          node = node.children[0];\n        } else if (parent) {\n          // go right\n          i++;\n          node = parent.children[i];\n          goingUp = false;\n        } else node = null; // nothing found\n\n      }\n\n      return this;\n    },\n    toBBox: function toBBox(item) {\n      return item;\n    },\n    compareMinX: function compareMinX(a, b) {\n      return a[0] - b[0];\n    },\n    compareMinY: function compareMinY(a, b) {\n      return a[1] - b[1];\n    },\n    toJSON: function toJSON() {\n      return this.data;\n    },\n    fromJSON: function fromJSON(data) {\n      this.data = data;\n      return this;\n    },\n    _all: function _all(node, result) {\n      var nodesToSearch = [];\n\n      while (node) {\n        if (node.leaf) result.push.apply(result, node.children);else nodesToSearch.push.apply(nodesToSearch, node.children);\n        node = nodesToSearch.pop();\n      }\n\n      return result;\n    },\n    _build: function _build(items, left, right, height) {\n      var N = right - left + 1,\n          M = this._maxEntries,\n          node;\n\n      if (N <= M) {\n        // reached leaf level; return leaf\n        node = {\n          children: items.slice(left, right + 1),\n          height: 1,\n          bbox: null,\n          leaf: true\n        };\n        calcBBox(node, this.toBBox);\n        return node;\n      }\n\n      if (!height) {\n        // target height of the bulk-loaded tree\n        height = Math.ceil(Math.log(N) / Math.log(M)); // target number of root entries to maximize storage utilization\n\n        M = Math.ceil(N / Math.pow(M, height - 1));\n      }\n\n      node = {\n        children: [],\n        height: height,\n        bbox: null,\n        leaf: false\n      }; // split the items into M mostly square tiles\n\n      var N2 = Math.ceil(N / M),\n          N1 = N2 * Math.ceil(Math.sqrt(M)),\n          i,\n          j,\n          right2,\n          right3;\n      multiSelect(items, left, right, N1, this.compareMinX);\n\n      for (i = left; i <= right; i += N1) {\n        right2 = Math.min(i + N1 - 1, right);\n        multiSelect(items, i, right2, N2, this.compareMinY);\n\n        for (j = i; j <= right2; j += N2) {\n          right3 = Math.min(j + N2 - 1, right2); // pack each entry recursively\n\n          node.children.push(this._build(items, j, right3, height - 1));\n        }\n      }\n\n      calcBBox(node, this.toBBox);\n      return node;\n    },\n    _chooseSubtree: function _chooseSubtree(bbox, node, level, path) {\n      var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n      while (true) {\n        path.push(node);\n        if (node.leaf || path.length - 1 === level) break;\n        minArea = minEnlargement = Infinity;\n\n        for (i = 0, len = node.children.length; i < len; i++) {\n          child = node.children[i];\n          area = bboxArea(child.bbox);\n          enlargement = enlargedArea(bbox, child.bbox) - area; // choose entry with the least area enlargement\n\n          if (enlargement < minEnlargement) {\n            minEnlargement = enlargement;\n            minArea = area < minArea ? area : minArea;\n            targetNode = child;\n          } else if (enlargement === minEnlargement) {\n            // otherwise choose one with the smallest area\n            if (area < minArea) {\n              minArea = area;\n              targetNode = child;\n            }\n          }\n        }\n\n        node = targetNode || node.children[0];\n      }\n\n      return node;\n    },\n    _insert: function _insert(item, level, isNode) {\n      var toBBox = this.toBBox,\n          bbox = isNode ? item.bbox : toBBox(item),\n          insertPath = []; // find the best node for accommodating the item, saving all nodes along the path too\n\n      var node = this._chooseSubtree(bbox, this.data, level, insertPath); // put the item into the node\n\n\n      node.children.push(item);\n      extend(node.bbox, bbox); // split on node overflow; propagate upwards if necessary\n\n      while (level >= 0) {\n        if (insertPath[level].children.length > this._maxEntries) {\n          this._split(insertPath, level);\n\n          level--;\n        } else break;\n      } // adjust bboxes along the insertion path\n\n\n      this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n    // split overflowed node into two\n    _split: function _split(insertPath, level) {\n      var node = insertPath[level],\n          M = node.children.length,\n          m = this._minEntries;\n\n      this._chooseSplitAxis(node, m, M);\n\n      var splitIndex = this._chooseSplitIndex(node, m, M);\n\n      var newNode = {\n        children: node.children.splice(splitIndex, node.children.length - splitIndex),\n        height: node.height,\n        bbox: null,\n        leaf: false\n      };\n      if (node.leaf) newNode.leaf = true;\n      calcBBox(node, this.toBBox);\n      calcBBox(newNode, this.toBBox);\n      if (level) insertPath[level - 1].children.push(newNode);else this._splitRoot(node, newNode);\n    },\n    _splitRoot: function _splitRoot(node, newNode) {\n      // split root node\n      this.data = {\n        children: [node, newNode],\n        height: node.height + 1,\n        bbox: null,\n        leaf: false\n      };\n      calcBBox(this.data, this.toBBox);\n    },\n    _chooseSplitIndex: function _chooseSplitIndex(node, m, M) {\n      var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n      minOverlap = minArea = Infinity;\n\n      for (i = m; i <= M - m; i++) {\n        bbox1 = distBBox(node, 0, i, this.toBBox);\n        bbox2 = distBBox(node, i, M, this.toBBox);\n        overlap = intersectionArea(bbox1, bbox2);\n        area = bboxArea(bbox1) + bboxArea(bbox2); // choose distribution with minimum overlap\n\n        if (overlap < minOverlap) {\n          minOverlap = overlap;\n          index = i;\n          minArea = area < minArea ? area : minArea;\n        } else if (overlap === minOverlap) {\n          // otherwise choose distribution with minimum area\n          if (area < minArea) {\n            minArea = area;\n            index = i;\n          }\n        }\n      }\n\n      return index;\n    },\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function _chooseSplitAxis(node, m, M) {\n      var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n          compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n          xMargin = this._allDistMargin(node, m, M, compareMinX),\n          yMargin = this._allDistMargin(node, m, M, compareMinY); // if total distributions margin value is minimal for x, sort by minX,\n      // otherwise it's already sorted by minY\n\n\n      if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function _allDistMargin(node, m, M, compare) {\n      node.children.sort(compare);\n      var toBBox = this.toBBox,\n          leftBBox = distBBox(node, 0, m, toBBox),\n          rightBBox = distBBox(node, M - m, M, toBBox),\n          margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n          i,\n          child;\n\n      for (i = m; i < M - m; i++) {\n        child = node.children[i];\n        extend(leftBBox, node.leaf ? toBBox(child) : child.bbox);\n        margin += bboxMargin(leftBBox);\n      }\n\n      for (i = M - m - 1; i >= m; i--) {\n        child = node.children[i];\n        extend(rightBBox, node.leaf ? toBBox(child) : child.bbox);\n        margin += bboxMargin(rightBBox);\n      }\n\n      return margin;\n    },\n    _adjustParentBBoxes: function _adjustParentBBoxes(bbox, path, level) {\n      // adjust bboxes along the given tree path\n      for (var i = level; i >= 0; i--) {\n        extend(path[i].bbox, bbox);\n      }\n    },\n    _condense: function _condense(path) {\n      // go through the path, removing empty nodes and updating bboxes\n      for (var i = path.length - 1, siblings; i >= 0; i--) {\n        if (path[i].children.length === 0) {\n          if (i > 0) {\n            siblings = path[i - 1].children;\n            siblings.splice(siblings.indexOf(path[i]), 1);\n          } else this.clear();\n        } else calcBBox(path[i], this.toBBox);\n      }\n    },\n    _initFormat: function _initFormat(format) {\n      // data format (minX, minY, maxX, maxY accessors)\n      // uses eval-type function compilation instead of just accepting a toBBox function\n      // because the algorithms are very sensitive to sorting functions performance,\n      // so they should be dead simple and without inner calls\n      var compareArr = ['return a', ' - b', ';'];\n      this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n      this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n      this.toBBox = new Function('a', 'return [a' + format.join(', a') + '];');\n    }\n  }; // calculate node's bbox from bboxes of its children\n\n  function calcBBox(node, toBBox) {\n    node.bbox = distBBox(node, 0, node.children.length, toBBox);\n  } // min bounding rectangle of node children from k to p-1\n\n\n  function distBBox(node, k, p, toBBox) {\n    var bbox = empty();\n\n    for (var i = k, child; i < p; i++) {\n      child = node.children[i];\n      extend(bbox, node.leaf ? toBBox(child) : child.bbox);\n    }\n\n    return bbox;\n  }\n\n  function empty() {\n    return [Infinity, Infinity, -Infinity, -Infinity];\n  }\n\n  function extend(a, b) {\n    a[0] = Math.min(a[0], b[0]);\n    a[1] = Math.min(a[1], b[1]);\n    a[2] = Math.max(a[2], b[2]);\n    a[3] = Math.max(a[3], b[3]);\n    return a;\n  }\n\n  function compareNodeMinX(a, b) {\n    return a.bbox[0] - b.bbox[0];\n  }\n\n  function compareNodeMinY(a, b) {\n    return a.bbox[1] - b.bbox[1];\n  }\n\n  function bboxArea(a) {\n    return (a[2] - a[0]) * (a[3] - a[1]);\n  }\n\n  function bboxMargin(a) {\n    return a[2] - a[0] + (a[3] - a[1]);\n  }\n\n  function enlargedArea(a, b) {\n    return (Math.max(b[2], a[2]) - Math.min(b[0], a[0])) * (Math.max(b[3], a[3]) - Math.min(b[1], a[1]));\n  }\n\n  function intersectionArea(a, b) {\n    var minX = Math.max(a[0], b[0]),\n        minY = Math.max(a[1], b[1]),\n        maxX = Math.min(a[2], b[2]),\n        maxY = Math.min(a[3], b[3]);\n    return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);\n  }\n\n  function contains(a, b) {\n    return a[0] <= b[0] && a[1] <= b[1] && b[2] <= a[2] && b[3] <= a[3];\n  }\n\n  function intersects(a, b) {\n    return b[0] <= a[2] && b[1] <= a[3] && b[2] >= a[0] && b[3] >= a[1];\n  } // sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n  // combines selection algorithm with binary divide & conquer approach\n\n\n  function multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n      right = stack.pop();\n      left = stack.pop();\n      if (right - left <= n) continue;\n      mid = left + Math.ceil((right - left) / n / 2) * n;\n      select(arr, left, right, mid, compare);\n      stack.push(left, mid, mid, right);\n    }\n  } // Floyd-Rivest selection algorithm:\n  // sort an array between left and right (inclusive) so that the smallest k elements come first (unordered)\n\n\n  function select(arr, left, right, k, compare) {\n    var n, i, z, s, sd, newLeft, newRight, t, j;\n\n    while (right > left) {\n      if (right - left > 600) {\n        n = right - left + 1;\n        i = k - left + 1;\n        z = Math.log(n);\n        s = 0.5 * Math.exp(2 * z / 3);\n        sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (i - n / 2 < 0 ? -1 : 1);\n        newLeft = Math.max(left, Math.floor(k - i * s / n + sd));\n        newRight = Math.min(right, Math.floor(k + (n - i) * s / n + sd));\n        select(arr, newLeft, newRight, k, compare);\n      }\n\n      t = arr[k];\n      i = left;\n      j = right;\n      swap(arr, left, k);\n      if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n      while (i < j) {\n        swap(arr, i, j);\n        i++;\n        j--;\n\n        while (compare(arr[i], t) < 0) {\n          i++;\n        }\n\n        while (compare(arr[j], t) > 0) {\n          j--;\n        }\n      }\n\n      if (compare(arr[left], t) === 0) swap(arr, left, j);else {\n        j++;\n        swap(arr, j, right);\n      }\n      if (j <= k) left = j + 1;\n      if (k <= j) right = j - 1;\n    }\n  }\n\n  function swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n  } // export as AMD/CommonJS module or global variable\n\n\n  if (typeof define === 'function' && define.amd) define('rbush', function () {\n    return rbush;\n  });else if (typeof module !== 'undefined') module.exports = rbush;else if (typeof self !== 'undefined') self.rbush = rbush;else window.rbush = rbush;\n})();","var data = require('./data.geo.json');\n\nvar createBaseTree = require('./base-tree.js');\n\nfunction createPolygon(coordinates, country) {\n  var coords = coordinates[0];\n  var minLng = coords[0][0];\n  var maxLng = coords[0][0];\n  var minLat = coords[0][1];\n  var maxLat = coords[0][1];\n\n  for (var i = 1; i < coords.length; i++) {\n    var point = coords[i];\n    if (point[0] < minLng) minLng = point[0];else if (point[0] > maxLng) maxLng = point[0];\n    if (point[1] < minLat) minLat = point[1];else if (point[1] > maxLat) maxLat = point[1];\n  }\n\n  return {\n    country: country,\n    coordinates: coordinates,\n    minLng: minLng,\n    minLat: minLat,\n    maxLng: maxLng,\n    maxLat: maxLat\n  };\n}\n\nfunction createNewTree() {\n  var tree = createBaseTree();\n  data.features.forEach(function (feature) {\n    var coordinates;\n\n    switch (feature.geometry.type) {\n      case 'Polygon':\n        coordinates = [feature.geometry.coordinates];\n        break;\n\n      case 'MultiPolygon':\n        coordinates = feature.geometry.coordinates;\n        break;\n\n      default:\n        throw new Error('Unsupported geometry');\n    }\n\n    coordinates.forEach(function (c) {\n      tree.insert(createPolygon(c, feature.id));\n    });\n  });\n  return tree;\n}\n\nmodule.exports = createNewTree;"],"sourceRoot":""}